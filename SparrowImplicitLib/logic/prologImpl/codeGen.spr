import nodes
import location
import ir
package meta
    import meta.sparrowNodes, meta.featherNodes, meta.compiler;

[ct] fun genProlog(sps: @SparrowPrologSystem): meta.AstNode = Impl.genPrologSystem(sps)

package Impl
    using meta.AstNode
    using meta.Location

    [ct] let nullNode: AstNode

    [ct] fun genPrologSystem(sps: @SparrowPrologSystem): AstNode
        let l = sps.loc
        var resNodes: Vector(AstNode)
        resNodes.reserve(3 * sps.predicates.size() + 3)

        // Add the import nodes
        resNodes += mkImportName(l, mkStringLiteral(l, "logic/lRef.spr"), nullNode, "")
        resNodes += mkImportName(l, mkStringLiteral(l, "logic/predicates.spr"), nullNode, "")
        resNodes += mkImportName(l, mkStringLiteral(l, "logic/recurse.spr"), nullNode, "")

        // Generate code for the predicates
        for p: @SparrowPredicate = sps.predicates.all()
            genPredicate(p, resNodes);
        //for n = resNodes.all()
        //    cout << ">> " << n.toStringExt() << endl;

        return mkNodeList(l, resNodes.all);

    [ct] fun genPredicate(pred: @SparrowPredicate, resNodes: @Vector(AstNode))
        let genNative = allowNativeCodeGen && pred.canBeNative

        let locPred = pred.firstClause.get().loc

        // Generate nodes for parameters and return type
        let paramsNode = genParameters(pred, genNative)
        let returnType = (
            ife(genNative
            , mkIdentifier(locPred, "Bool")
            , mkIdentifier(locPred, "Predicate"))
        )

        var bodyNodes: Vector(AstNode)

        // Add local variables to body nodes
        for lv: @ExpressionPtr = pred.localVars.all()
            let locVar = lv.get().loc
            let typeName = getTypeName(pred, lv.get(), false, genNative)
            var init = nullNode
            if ( genNative )
                // Don't initialize native integers
                var typeSet: @LTypeSet = pred.typeSets(lv.get().typeSetIdx)
                if ( typeSet.type.isNumberOnly() )
                    init = mkFunApplication(locVar, mkIdentifier(locVar, "Uninitialized"), nullNode);
            bodyNodes.pushBack(mkSprVariable(locVar, lv.get().data.asStringRef(), typeName, init))

        // Add the main logic as a disjunction of all the clauses
        var logicNode: AstNode
        for clause: @PredicateClausePtr = pred.clauses.all()
            let clauseNode = genClause(pred, clause.get())
            if ( clauseNode isSet )
                if ( logicNode isNull )
                    logicNode = clauseNode;
                else
                    logicNode = mkInfixOp(logicNode location, "||", logicNode, clauseNode);
            ;
        //let logicNode = mkFunApplication(locPred, mkIdentifier(locPred, "mkTrue"), nullNode);
        bodyNodes.pushBack(mkReturnStmt(locPred, logicNode))

        // Finally create the function node
        let body = mkLocalSpace(locPred, bodyNodes.all)
        var funName = pred.name
        if ( genNative )
            funName += "_native";
        let res = mkSprFunction(locPred, funName.asStringRef(), paramsNode, returnType, body, nullNode)
        resNodes.pushBack(res)

        if ( genNative )
            resNodes.pushBack(genWrapperClass(pred))
            resNodes.pushBack(genWrapperPredicate(pred))
        ;

    [ct] fun genParameters(pred: @SparrowPredicate, genNative: Bool): AstNode
        let locPred = pred.firstClause.get().loc
        let params = mkNodeList(locPred, AstNodeRange(), true)
        for i = 0..pred.paramVars.size()
            let param: @Parameter = pred.paramVars(i)
            let p: @Expression = param.expr.get()
            let locParam = p.loc
            let paramName = String("p_") + intToString(Int(i+1))
            let isRef = !genNative || param.isOutput
            let typeName = getTypeName(pred, p, isRef, genNative)
            addToNodeList(params, mkSprParameter(locParam, paramName.asStringRef(), typeName, nullNode))
        return params

    [ct] fun genClause(pred: @SparrowPredicate, clause: @PredicateClause): AstNode
        var res = nullNode
        res = genBoundArgs(pred, clause)
        res = genConditions(pred, clause, res)
        if ( res isNull )
            let loc = clause.loc
            res = mkFunApplication(loc, mkIdentifier(loc, "mkTrue"), nullNode)
        return res

    [ct] fun genBoundArgs(pred: @SparrowPredicate, clause: @PredicateClause): AstNode
        let genNative = allowNativeCodeGen && pred.canBeNative

        var res = nullNode
        for i = 0..clause.args.size()
            let arg: @ExpressionPtr = clause.args(i)
            if ( arg.isSet() && arg.get().kind != ekVar )
                let loc = arg.get().loc
                let name = String("p_") + intToString(Int(i+1))
                let argName = mkIdentifier(loc, name.asStringRef())
                let argValue = genExpr(pred, arg.get())

                let idx = arg.get().paramIdx
                assert(idx >= 0)
                let param: @Parameter = pred.paramVars(idx)
                var oper: String
                if ( genNative && param.isInput )
                    oper = "==";
                else if ( genNative && param.isOutput )
                    oper = "=/";
                else
                    oper = "/=/";
                let thisCond = mkInfixOp(loc, oper.asStringRef(), argName, argValue)

                res = chainConditions(loc, res, thisCond)
            ;
        return res

    [ct] fun genConditions(pred: @SparrowPredicate, clause: @PredicateClause, prevCond: AstNode): AstNode
        for cond: @ConditionPtr = clause.conditions.all()
            let thisCond = nullNode
            if ( cond.get().kind == ckPredCall )
                thisCond = genPredCall(pred, clause, cond.get());
            else
                thisCond = genIsExpr(pred, clause, cond.get());

            prevCond = chainConditions(cond.get().loc, prevCond, thisCond);
        return prevCond

    [ct] fun chainConditions(loc: @Location, prev, cur: AstNode): AstNode
        if ( cur isSet )
            if ( prev isNull )
                prev = cur;
            else
                prev = mkInfixOp(loc, "&&", prev, cur);
        return prev

    [ct] fun genPredCall(pred: @SparrowPredicate, clause: @PredicateClause, predCall: @Condition): AstNode
        let loc = predCall.loc

        let genNative = allowNativeCodeGen && pred.canBeNative
        let isRecursive = predCall.predName == clause.name

        var argsAst = mkNodeList(loc, AstNodeRange(), true)
        let size = predCall.args.size()
        if ( isRecursive && !genNative )
            ++size;
        if ( isRecursive && !genNative )
            addToNodeList(argsAst, mkPrefixOp(loc, "\\", mkIdentifier(loc, predCall.predName.asStringRef())));
        for arg: @ExpressionPtr = predCall.args.all()
            addToNodeList(argsAst, genExpr(pred, arg.get()) );

        var funName: AstNode
        if ( isRecursive )
            if ( genNative )
                funName = mkIdentifier(loc, predCall.predName.asStringRef() + "_native");
            else
                funName = mkIdentifier(loc, "rec");
        else
            funName = mkIdentifier(loc, predCall.predName.asStringRef());
        return mkFunApplication(loc, funName, argsAst);

    [ct] fun genIsExpr(pred: @SparrowPredicate, clause: @PredicateClause, isExpr: @Condition): AstNode
        let genNative = allowNativeCodeGen && pred.canBeNative
        let op = ife(genNative, "=/", "/=/")
        return mkInfixOp(isExpr.loc, op,
            genExpr(pred, isExpr.args(0).get()),
            genExpr(pred, isExpr.args(1).get()))

    [ct] fun genExpr(pred: @SparrowPredicate, expr: @Expression): AstNode
        let genNative = allowNativeCodeGen && pred.canBeNative
        let loc = expr.loc
        if ( expr.kind == ekAtom )
            return mkStringLiteral(loc, expr.data.asStringRef());
        if ( expr.kind == ekNumber )
            return mkIntLiteral(loc, asInt(expr.data.asStringRef()));
        if ( expr.kind == ekVar )
            return mkIdentifier(loc, expr.data.asStringRef());
        if ( expr.kind == ekAntiQuote )
            return generateNodeForSparrowExp(loc, expr.data);
        if ( expr.kind == ekOpPlus )
            return mkInfixOp(loc, ife(genNative, "+", "/+/"), genExpr(pred, expr.left.get()), genExpr(pred, expr.right.get()));
        if ( expr.kind == ekOpMinus )
            return mkInfixOp(loc, ife(genNative, "-", "/-/"), genExpr(pred, expr.left.get()), genExpr(pred, expr.right.get()));
        if ( expr.kind == ekOpMul )
            return mkInfixOp(loc, ife(genNative, "*", "|*|"), genExpr(pred, expr.left.get()), genExpr(pred, expr.right.get()));
        if ( expr.kind == ekOpDiv )
            return mkInfixOp(loc, ife(genNative, "/", "|/|"), genExpr(pred, expr.left.get()), genExpr(pred, expr.right.get()));
        assert("Invalid expression kind while generating code" != "")
        return nullNode

    [ct] fun generateNodeForSparrowExp(loc: meta.Location, exp: @String): AstNode
        return meta.parseSprExpression(loc, exp.asStringRef());
        //let sz = exp.size();
        //if ( sz == 0 )
        //    return mkNop(loc);
        //if ( sz >= 2 && exp.front() == '"'.char && exp.back() == '"'.char )
        //    return mkStringLiteral(loc, String(exp.subrange(1, sz-2)).asStringRef());
        //if ( sz > 2 && exp(sz-2) == '('.char && exp(sz-1) == ')'.char )
        //    return mkFunApplication(loc, mkIdentifier(loc, String(exp.subrange(0, sz-2)).asStringRef()), nullNode);

        //return mkIdentifier(loc, exp.asStringRef());

    [ct] fun getTypeName(pred: @SparrowPredicate, expr: @Expression, addRef: Bool, genNative: Bool): AstNode
        assert(expr.typeSetIdx >= 0)
        let typeSet: @LTypeSet = pred.typeSets(expr.typeSetIdx)
        var str: StringRef
        if ( typeSet.type.isNumberOnly() )
            str = ife(genNative, "Int", "LInt");
        else
            str = ife(genNative, "String", "LStr");
        let loc = expr.loc
        //cout << "TypeName: " << str << " for " << expr << " with type=" << typeSet.type.bits << endl << flush;
        var res = ife(genNative, mkIdentifier(loc, str), mkIdentifier(loc, str))
        if ( addRef )
            res = mkPrefixOp(loc, "@", res);
        return res;

    [ct] fun genWrapperClass(pred: @SparrowPredicate): AstNode
        let loc = pred.firstClause.get().loc

        var children = mkNodeList(loc, AstNodeRange(), true)
        if ( pred.arity > 0 )
            genWrapperClassVars(pred, children)
            addToNodeList(children, genWrapperClassCtor(pred))
        addToNodeList(children, genWrapperClassCallOper(pred))

        let clsName = pred.name + "_pred_wrapper"
        return mkSprDatatype(loc, clsName.asStringRef(), nullNode, nullNode, nullNode, children)

    [ct] fun genWrapperClassVars(pred: @SparrowPredicate, classChildren: @AstNode)
        for i = 0..pred.paramVars.size()
            let pe: @Expression = pred.paramVars(i).expr.get()
            let paramName = String("p_") + intToString(Int(i+1))
            let locVar = pe.loc
            let typeName = getTypeName(pred,pe, false, false)
            addToNodeList(classChildren, mkSprVariable(locVar, paramName.asStringRef(), typeName, nullNode))
        ;
    [ct] fun genWrapperClassCtor(pred: @SparrowPredicate): AstNode
        let loc = pred.firstClause.get().loc

        // Create the body
        var bodyNodes: Vector(AstNode)
        bodyNodes.reserve(pred.arity)
        for i = 0..pred.paramVars.size()
            let pe: @Expression = pred.paramVars(i).expr.get()
            let locParam = pe.loc
            let paramName = String("p_") + intToString(Int(i+1))
            let left = mkCompoundExp(locParam, mkIdentifier(locParam, "this"), paramName.asStringRef())
            let right = mkIdentifier(locParam, paramName.asStringRef())
            bodyNodes.pushBack(mkInfixOp(locParam, "ctor", left, right))
        let body = mkLocalSpace(loc, bodyNodes.all)

        // Finally create the function node
        let paramsNode = genParameters(pred, false)
        return mkSprFunction(loc, "ctor", paramsNode, nullNode, body, nullNode)
    [ct] fun genWrapperClassCallOper(pred: @SparrowPredicate): AstNode
        let loc = pred.firstClause.get().loc
        var bodyNodes: Vector(AstNode)
        bodyNodes.reserve(pred.arity + 1)

        // Checks for the input parameters
        var inputChecks = nullNode
        for i = 0..pred.paramVars.size()
            let p: @Parameter = pred.paramVars(i)
            if ( p.isInput )
                let pe: @Expression = p.expr.get()
                let locParam = pe.loc
                let paramName = String("p_") + intToString(Int(i+1))

                let callFn = mkCompoundExp(locParam, mkIdentifier(locParam, paramName.asStringRef()), "isNull")
                let call = mkFunApplication(locParam, callFn, nullNode)

                if ( inputChecks isNull )
                    inputChecks = call;
                else
                    inputChecks = mkInfixOp(locParam, "||", inputChecks, call);
            ;
        if ( inputChecks isSet )
            let thenClause = mkReturnStmt(loc, mkBoolLiteral(loc, false))
            let ifStmt = mkIf(loc, inputChecks, thenClause, nullNode)
            bodyNodes.pushBack(ifStmt)

        // Create some values for the output parameters
        for i = 0..pred.paramVars.size()
            let p: @Parameter = pred.paramVars(i)
            if ( p.isOutput )
                let pe: @Expression = p.expr.get()
                let locParam = pe.loc
                let paramName = String("p_") + intToString(Int(i+1))

                let paramId = mkIdentifier(locParam, paramName.asStringRef())
                let ctorCall = mkFunApplication(locParam, getTypeName(pred, pe, false, true), nullNode)
                let valSet = mkInfixOp(locParam, "=", paramId, ctorCall)
                bodyNodes.pushBack(valSet)
            ;

        // The call to the native function
        var callArgsNode = mkNodeList(loc, AstNodeRange(), true)
        for i = 0..pred.paramVars.size()
            let p: @Parameter = pred.paramVars(i)
            let pe: @Expression = p.expr.get()
            let locParam = pe.loc
            let paramName = String("p_") + intToString(Int(i+1))

            let paramId = mkIdentifier(locParam, paramName.asStringRef())
            let getName = mkCompoundExp(locParam, paramId, "get")
            let getCall = mkFunApplication(locParam, getName, nullNode)
            addToNodeList(callArgsNode, getCall)
        let nativeFunName = mkIdentifier(loc, (pred.name + "_native").asStringRef())
        let nativeFunCall = mkFunApplication(loc, nativeFunName, callArgsNode)
        bodyNodes.pushBack(mkReturnStmt(loc, nativeFunCall))

        // Finally create the function node
        let body = mkLocalSpace(loc, bodyNodes.all)
        let returnType = mkIdentifier(loc, "Bool")
        return mkSprFunction(loc, "()", nullNode, returnType, body, nullNode)
    [ct] fun genWrapperPredicate(pred: @SparrowPredicate): AstNode
        let loc = pred.firstClause.get().loc

        // Create the function application to call the predicate wrapper ctor
        var argsAst = mkNodeList(loc, AstNodeRange(), true)
        for i = 0..pred.paramVars.size()
            let p: @Expression = pred.paramVars(i).expr.get()
            let locParam = p.loc
            let paramName = String("p_") + intToString(Int(i+1))
            addToNodeList(argsAst, mkIdentifier(locParam, paramName.asStringRef()))
        let funName = mkIdentifier(loc, pred.name.asStringRef() + "_pred_wrapper")
        let bodyExp = mkFunApplication(loc, funName, argsAst)

        // Finally create the function node
        let paramsNode = genParameters(pred, false)
        let returnType = mkIdentifier(loc, "Predicate")
        return mkSprFunctionExp(loc, pred.name.asStringRef(), paramsNode, returnType, bodyExp, nullNode)
    ;
