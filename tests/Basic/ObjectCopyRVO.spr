//!! -t "SparrowImplicitLib.spr" -fno-main

datatype MyType
    x: Int;

fun ctor(this: !MyType)
    writeLn("ctor()");
fun ctor(this: !MyType, i: Int)
    x = i
    write("ctor("); write(x); writeLn(")")
fun ctor(this: !MyType, other: MyType)
    x = other.x
    write("copy ctor("); write(x); writeLn(")")
fun dtor(this: !MyType)
    write("dtor-"); writeLn(x);

fun =(this, other: !MyType)
    write("assign("); write(other.x); writeLn(")")
    x = other.x

fun f1(): MyType
    return MyType(101);
fun f2 = MyType(102)
fun f3: MyType
    let x = MyType(103)
    return x

[native("test")]
fun test(n: Int)
    if      n == 1; test1
    else if n == 2; test2
    else if n == 3; test3
    else if n == 4; test4
    else if n == 5; test5

fun test1
    let o1: MyType
    let o2: MyType = 1
    MyType(10)
    MyType(o2)
    let o3 = o1
    let o4 = MyType(100)
    writeLn("done")

/*<<<Basic test(1)
ctor()
ctor(1)
ctor(10)
dtor-10
copy ctor(1)
dtor-1
copy ctor(0)
ctor(100)
done
dtor-100
dtor-0
dtor-1
dtor-0
>>>*/

fun test2
    let x = MyType(10);
/*<<<Object construction(2)
ctor(10)
dtor-10
>>>*/

fun test3
    f1()
    writeLn("---")
    f2()
    writeLn("---")

    var x: MyType
    x = f1()
/*<<<Function call(3)
ctor(101)
dtor-101
---
ctor(102)
dtor-102
---
ctor()
ctor(101)
assign(101)
dtor-101
dtor-101
>>>*/

fun test4
    let x = f1();
/*<<<Put result of a function call into a variable(4)
ctor(101)
dtor-101
>>>*/

fun test5
    let x = f3();
    // NRVO will reduce onece more the ctor call - right now we have an extra copy
/*<<<Fn call to function that returns by name(5)
ctor(103)
copy ctor(103)
dtor-103
dtor-103
>>>*/
