//!!
import logic.prologFrontend;


fun fib_native(p_1: Int, p_2: @Int): Bool
{
    var l2_X2: Int = Uninitialized();
    var l2_Y2: Int = Uninitialized();
    var l2_X1: Int = Uninitialized();
    var l2_Y1: Int = Uninitialized();
    return ( p_1 == 0 && p_2 =/ 0
        || p_1 == 1 && p_2 =/ 1
        || l2_X2 =/ (p_1 - 2) && fib_native(l2_X2, l2_Y2) && l2_X1 =/ (p_1 - 1) && fib_native(l2_X1, l2_Y1) && p_2 =/ (l2_Y1 + l2_Y2)
        );
}
datatype fib_pred_wrapper
    p_1: LInt;
    p_2: LInt;
fun ctor(this: @fib_pred_wrapper, p_1: @LInt, p_2: @LInt)
{
    this.p_1 ctor p_1;
    this.p_2 ctor p_2;
}
fun ()(this: @fib_pred_wrapper): Bool
{
    if ( p_1.isNull() )
        return false;
    p_2 = Int();
    return fib_native(p_1.get(), p_2.get());
}
fun fib(p_1: @LInt, p_2: @LInt): Predicate = fib_pred_wrapper(p_1, p_2);

fun sprMain
{
    if ( programArgs.size() < 2 )
        return;
    var n = programArgs(1) asInt;

    var res: LInt;
    cout << fib(n, res)() << endl;
    cout << "res=" << res.get() << endl;
}

/*<<<Logic Fibonacci (10)
true
res=55
>>>*/

/*<<<Logic Fibonacci (20)
true
res=6765
>>>*/
