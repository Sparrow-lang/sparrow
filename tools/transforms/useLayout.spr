//! Transformation that uses spaces & layout in favor of curly braces
module formatTool.transforms.useLayout

import utils
import formatDetails.sourceData

fun useLayoutFormatter(src: @SourceData)
    var parenCount = 0

    var prevLineIndent = 1
    var curLineIndent = 1
    var hasNonSpace = false
    var lastLine = 0    // last line that contained a printable token

    var curlyStack: OpenCurlyInfo Vector

    for i = 0..Int(src.tokens.size)
        var tok: @TokenData = src.tokens(i)
        var remaining = src.tokens.subrange(i+1)

        if tok.type == tkLPAREN
            parenCount++
        else if tok.type == tkRPAREN && parenCount > 0
            parenCount--

        // Check for layout change
        if tok.type != tkWHITESPACE && tok.type != tkCOMMENT && tok.type != tkEOL
            if tok.loc.start.line != lastLine
                prevLineIndent = curLineIndent
                curLineIndent = Int(tok.loc.start.col)
                lastLine = Int(tok.loc.start.line)

        // Detect open-curly tokens; store the info in our stack
        // The decision to remove this or not will be made at the close-curly
        if tok.type == tkLCURLY
            var canRemove = tok.canFormat && nextIsNewline(remaining) \
                && _getNextLineIndent(remaining) > curLineIndent
            curlyStack += OpenCurlyInfo(i, curLineIndent, canRemove)

        if tok.type == tkRCURLY
            if curlyStack.isEmpty
                reportError(tok.loc, 'Close curly found without the matching open curly')

            // Take the open curly info off our stack
            var openInfo = curlyStack.back
            curlyStack.popBack

            // Can we remove both tokens?
            var canRemove = openInfo.canRemove && tok.canFormat && nextIsNewline(remaining) \
                && prevLineIndent > curLineIndent
            if canRemove
                clearTokenLine(openInfo.idx, src.tokens)
                clearTokenLine(i, src.tokens)

fun _getNextLineIndent(remaining: TokensRange): Int
    if remaining.isEmpty
        return 1
    var line = remaining.front().loc.start.line
    for tok: @TokenData = remaining
        var tk = tok.type
        if tk == tkEOL || tk == tkEND || tk == tkWHITESPACE || tk == tkCOMMENT
            continue
        else
            return Int(tok.loc.start.col)
    return 1

//! Information to be kept for an open-curly.
//! Needed to reason about what to do with the curly-pair, when reaching the close-curly.
[initCtor]
datatype OpenCurlyInfo
    idx: Int        //!< The index in the tokens vector where the open-curly is found
    lineIndent: Int //!< The indent of the line containing the open-curly
    canRemove: Bool //!< True if we can eliminate this curly
